
1. CAESAR CIPHER
Client- Server Program ( Encryption at Client, Decryption at Server)
#Server
import socket as sc
def decrypt(s,key):
    d=""
    al="abcdefghijklmnopqrstuvwxyz"
    cap_al="ABCDEFGHIJKLMNOPQRSTUVWXYZ"
    num="0123456789"
    for i in s:
        if i in al:
            c=(ord(i)-97-key)%26
            d=d+al[c]
        elif i in cap_al:
            c=(ord(i)-65-key)%26
            d=d+cap_al[c]
        elif i in num:
            d=d+str((int(i)-key)%10)
        else:
            d=d+i            
    return d    
host=sc.gethostname()
port=5110
server=sc.socket()
server.bind((host,port))
server.listen(2)
print("Server Listening at port: ",port)
con,add=server.accept()
print("Successfully connected with: "+str(add))
key=int(con.recv(1024).decode())
print("Cipher Key: ",key)
while True:
    req=con.recv(1024).decode()
    if not req:
        break
    print("Encrypted Message from Client: ",req)
    print("Actual Message from Client: ",decrypt(req,key))
con.close()    

#Client
import socket as sc
def encrypt(s,key):
    e=""
    al="abcdefghijklmnopqrstuvwxyz"
    cap_al="ABCDEFGHIJKLMNOPQRSTUVWXYZ"
    num="0123456789"
    for i in s:
        if i in al:
            c=(ord(i)-97+key)%26
            e=e+al[c]
        elif i in cap_al:
            c=(ord(i)-65+key)%26
            e=e+cap_al[c]
        elif i in num:
            e=e+str((int(i)+key)%10)
        else:
            e=e+i
    return e
host=sc.gethostname()
port=5110
client=sc.socket()
client.connect((host,port))
key=input("Enter Caesar Cipher Key: ")
client.send(key.encode())
req=input("Enter Message to Server: ")
while True:
    if req=="Bye":
        break
    encrypt_msg=encrypt(req,int(key))
    client.send(encrypt_msg.encode())
    print("Encrypted Message sent to Server: ",encrypt_msg)
    req=input("Enter Message to Server: ")
client.close()


2.	VIGENERE CIPHER

Client- Server Program ( Encryption at Client, Decryption at Server)
#Server
import socket as sc
def vernam_decrypt(req,key):
    d = ""
    for i in range(len(req)):
        d+=''.join(chr(ord(req[i])^ord(key[i])))
    return d
host=sc.gethostname()
port=5110
server=sc.socket()
server.bind((host,port))
server.listen(2)
print("Server Listening at port: ",port)
con,add=server.accept()
print("Successfully connected with: "+str(add))
key=con.recv(1024).decode()
print("Cipher Key: ",key)
while True:
    req=con.recv(1024).decode()
    if not req:
        break
    print("Encrypted Message from Client: ",req)
    print("Actual Message from Client: ",vernam_decrypt(req,key))
con.close()    


#Client
import socket as sc
def vernam_encrypt(req,key):
    e = ""
    for i in range(len(req)):
        e+=chr(ord(req[i])^ord(key[i]))
    return e
host=sc.gethostname()
port=5110
client=sc.socket()
client.connect((host,port))
key=input("Enter Cipher Key: ")
client.send(key.encode())
req=input("Enter Message to Server: ")
while True:
    if req=="Bye":
        break
    encrypt_msg=vernam_encrypt(req,key)
    client.send(encrypt_msg.encode())
    print("Encrypted Message sent to Server: ",encrypt_msg)
    req=input("Enter Message to Server: ")
client.close()


3.	VERNAM CIPHER
Client- Server Program ( Encryption at Client, Decryption at Server)
#Server
import socket as sc

def vernam_decrypt(req,key):
    d = ""
    for i in range(len(req)):
        d+=''.join(chr(ord(req[i])^ord(key[i])))
    return d

host=sc.gethostname()
port=5110
server=sc.socket()
server.bind((host,port))
server.listen(2)
print("Server Listening at port: ",port)
con,add=server.accept()
print("Successfully connected with: "+str(add))
key=con.recv(1024).decode()
print("Cipher Key: ",key)
while True:
    req=con.recv(1024).decode()
    if not req:
        break
    print("Encrypted Message from Client: ",req)
    print("Actual Message from Client: ",vernam_decrypt(req,key))
con.close()    


#Client
import socket as sc
def vernam_encrypt(req,key):
    e = ""
    for i in range(len(req)):
        e+=chr(ord(req[i])^ord(key[i]))
    return e

host=sc.gethostname()
port=5110
client=sc.socket()
client.connect((host,port))
key=input("Enter Cipher Key: ")
client.send(key.encode())
req=input("Enter Message to Server: ")
while True:
    if req=="Bye":
        break
    encrypt_msg=vernam_encrypt(req,key)
    client.send(encrypt_msg.encode())
    print("Encrypted Message sent to Server: ",encrypt_msg)
    req=input("Enter Message to Server: ")
client.close()



4.	RAILFENCE CIPHER
Client- Server Program ( Encryption at Client, Decryption at Server)
#Server
import socket as sc
def railfence_decrypt(text,key):
    result = ""
    mrx = [ ["" for j in range(len(text))] for i in range(key)]
    row,col = 0,0
    down = False
    for i in range(len(text)):
        mrx[row][col] = "-"
        if row == 0 or row == key-1:
            down = not down
        if down:
            row += 1
        else:
            row -= 1
        col += 1
    k = 0
    for i in range(key):
        for j in range(len(text)):
            if(mrx[i][j] == "-"):
                mrx[i][j] = text[k]
                k+=1
    row,col = 0,0
    down = False
    for i in range(len(text)):
        result += mrx[row][col]
        if row == 0 or row == key-1:
            down = not down  
        if down:
            row += 1
        else:
            row -= 1  
        col += 1
    return result

host=sc.gethostname()
port=5110
server=sc.socket()
server.bind((host,port))
server.listen(2)
print("Server Listening at port: ",port)
con,add=server.accept()
print("Successfully connected with: "+str(add))
key=con.recv(1024).decode()
print("Cipher Key (No.of Rows): ",key)
while True:
    req=con.recv(1024).decode()
    if not req:
        break
    print("Encrypted Message from Client: ",req)
    print("Actual Message from Client: ",railfence_decrypt(req,int(key)))
con.close()    

#Client
import socket as sc
def railfence_encrypt(text,key):
    result = ''
    mrx = [ ["" for i in range(len(text))] for j in range(key)]
    row,col = 0,0
    down = False
    for i in range(len(text)):
        if(row == key-1 or row == 0):
            down = not down
        mrx[row][col] = text[i]
        col+=1
        if down:
            row += 1
        else: 
            row -= 1
    i = 0
    for i in range(key):
        for j in range(len(text)):
            if(mrx[i][j] != ""):
                result+=mrx[i][j]
       return result

host=sc.gethostname()
port=5110
client=sc.socket()
client.connect((host,port))
key=input("Enter Cipher Key (No.of Rows): ")
client.send(key.encode())
req=input("Enter Message to Server: ")
while True:
    if req=="Bye":
        break
    encrypt_msg=railfence_encrypt(req,int(key))
    client.send(encrypt_msg.encode())
    print("Encrypted Message sent to Server: ",encrypt_msg)
    req=input("Enter Message to Server: ")
client.close()


5.	ROW COLUMN CIPHER
Client- Server Program ( Encryption at Client, Decryption at Server)
#Server
import socket as sc
def decrypt(text,key):
    result = ""
    mrx = [ ["" for j in range(len(text))] for i in range(key)]
    row,col = 0,0
    down = False
    for i in range(len(text)):
        mrx[row][col] = '-'
        if row == 0 or row == key-1:
            down = not down  
        if down:
            row += 1
        else:
            row -= 1
        col += 1
    k = 0
    for i in range(key):
        for j in range(len(text)):
            if(mrx[i][j] == '-'):
                mrx[i][j] = text[k]
                k+=1
    row,col = 0,0
    down = False
    for i in range(len(text)):
        result += mrx[row][col]
        if row == 0 or row == key-1:
            down = not down
        if down:
            row += 1
        else:
            row -= 1
        col += 1
    return result
host=sc.gethostname()
port=5110
server=sc.socket()
server.bind((host,port))
server.listen(2)
print("Server Listening at port: ",port)
con,add=server.accept()
print("Successfully connected with: "+str(add))
key=con.recv(1024).decode()
print("Cipher Key (No.of Rows): ",key)
while True:
    req=con.recv(1024).decode()
    if not req:
        break
    print("Encrypted Message from Client: ",req)
    print("Actual Message from Client: ",decrypt(req,int(key)))
con.close()    

#Client
import socket as sc
def encrypt(text,key):
    result = ''
    mrx = [ ["" for i in range(len(text))] for j in range(key)]
    row,col = 0,0
    down = False
    for i in range(len(text)):
        if(row == key-1 or row == 0):
            down = not down
        mrx[row][col] = text[i]
        col+=1
        if down:
            row += 1
        else:
            row -= 1
    i = 0
    for i in range(key):
        for j in range(len(text)):
            if(mrx[i][j] != ""):
                result+=mrx[i][j]
    return result
host=sc.gethostname()
port=5110
client=sc.socket()
client.connect((host,port))
key=input("Enter Cipher Key (No.of Rows): ")
client.send(key.encode())
req=input("Enter Message to Server: ")
while True:
    if req=="Bye":
        break
    encrypt_msg=encrypt(req,int(key))
    client.send(encrypt_msg.encode())
    print("Encrypted Message sent to Server: ",encrypt_msg)
    req=input("Enter Message to Server: ")
client.close()


1)	PlayFair
Code:
Server:
import socket
import string
def generate_playfair_key(secure_key):
    letters = string.ascii_lowercase.replace('j', '.')
    secure_key = secure_key.lower()
    key_grid = ['' for _ in range(5)]
    row = 0
    col = 0
    for char in secure_key:
        if char in letters:
            key_grid[row] += char
            letters = letters.replace(char, '.')
            col += 1
            if col > 4:
                row += 1
                col = 0
    for char in letters:
        if char != '.':
            key_grid[row] += char
            col += 1
            if col > 4:
                row += 1
                col = 0

    return key_grid
def playfair_encrypt(text, key_grid):
    text_pairs = []
    encrypted_pairs = []
    text = text.replace(" ", "").lower()
    idx = 0
    while idx < len(text):
        a = text[idx]
        b = 'x' if (idx + 1) == len(text) else text[idx + 1]
        if a != b:
            text_pairs.append(a + b)
            idx += 2
        else:
            text_pairs.append(a + 'x')
            idx += 1
    for pair in text_pairs:
        found = False
        for row in key_grid:
            if pair[0] in row and pair[1] in row:
                pos0 = row.find(pair[0])
                pos1 = row.find(pair[1])
                encrypted_pairs.append(row[(pos0 + 1) % 5] + row[(pos1 + 1) % 5])
                found = True
                break
        if found:
            continue


        for col in range(5):
            col_content = "".join([key_grid[i][col] for i in range(5)])
            if pair[0] in col_content and pair[1] in col_content:
                pos0 = col_content.find(pair[0])
                pos1 = col_content.find(pair[1])
                encrypted_pairs.append(col_content[(pos0 + 1) % 5] + col_content[(pos1 + 1) % 5])
                found = True
                break
        if found:
            continue
        row0, col0 = [(i, row.find(pair[0])) for i, row in enumerate(key_grid) if pair[0] in row][0]
        row1, col1 = [(i, row.find(pair[1])) for i, row in enumerate(key_grid) if pair[1] in row][0]
        encrypted_pairs.append(key_grid[row0][col1] + key_grid[row1][col0])
    encrypted_text = "".join(encrypted_pairs)
    return encrypted_text

def start_server():
    host = socket.gethostname()
    port = 5001
    server_sock = socket.socket()
    server_sock.bind((host, port))
    server_sock.listen(2)
    conn, addr = server_sock.accept()
    while True:
        secure_key = input('Enter the key: ')
        key_grid = generate_playfair_key(secure_key)
        message = input("Enter the message: ")
        encrypted_message = playfair_encrypt(message, key_grid)
        full_message = encrypted_message + "|" + secure_key
        if not secure_key or not message:
            break
        conn.send(full_message.encode())
    conn.close()
if __name__ == '__main__':
    start_server()	

Client:
import socket
import string
def generate_playfair_key(secure_key):
    letters = string.ascii_lowercase.replace('j', '.')
    secure_key = secure_key.lower()
    key_grid = ['' for _ in range(5)]
    row = 0
    col = 0
    for char in secure_key:
        if char in letters:
            key_grid[row] += char
            letters = letters.replace(char, '.')
            col += 1
            if col > 4:
                row += 1
                col = 0
    for char in letters:
        if char != '.':
            key_grid[row] += char
            col += 1
            if col > 4:
                row += 1
                col = 0
    return key_grid

def playfair_decrypt(encrypted_text, key_grid):
    text_pairs = []
    decrypted_pairs = []
    encrypted_text = encrypted_text.lower()
    idx = 0
    while idx < len(encrypted_text):
        a = encrypted_text[idx]
        b = encrypted_text[idx + 1]
        text_pairs.append(a + b)
        idx += 2
    for pair in text_pairs:
        found = False
        for row in key_grid:
            if pair[0] in row and pair[1] in row:
                pos0 = row.find(pair[0])
                pos1 = row.find(pair[1])
                decrypted_pairs.append(row[(pos0 + 4) % 5] + row[(pos1 + 4) % 5])
                found = True
                break
        if found:
            continue
        for col in range(5):
            col_content = "".join([key_grid[i][col] for i in range(5)])
            if pair[0] in col_content and pair[1] in col_content:
                pos0 = col_content.find(pair[0])
                pos1 = col_content.find(pair[1])
                decrypted_pairs.append(col_content[(pos0 + 4) % 5] + col_content[(pos1 + 4) % 5])
                found = True
                break
        if found:
            continue
        row0, col0 = [(i, row.find(pair[0])) for i, row in enumerate(key_grid) if pair[0] in row][0]
        row1, col1 = [(i, row.find(pair[1])) for i, row in enumerate(key_grid) if pair[1] in row][0]
        decrypted_pairs.append(key_grid[row0][col1] + key_grid[row1][col0])

    decrypted_text = "".join(decrypted_pairs)

    return decrypted_text

def start_client():
    host = socket.gethostname()
    port = 5001
    client_sock = socket.socket()
    client_sock.connect((host, port))
    while True:
        received_data = client_sock.recv(1024).decode()
        if not received_data:
            break
        parts = received_data.split("|")
        encrypted_message = parts[0]
        secure_key = parts[1]
        key_grid = generate_playfair_key(secure_key)
        decrypted_message = playfair_decrypt(encrypted_message, key_grid)
    client_sock.close()

if __name__ == '__main__':
    start_client()


Code Hill Cipher:
CODE:
Sender:
import socket
import string

alphabet = string.ascii_lowercase

def generate_matrix(order):
    matrix = []
    for i in range(order):
        row = [int(num) for num in input(f"Enter row {i}: ").split()]
        matrix.append(row)
    return matrix

def matrix_to_string(matrix):
    key_str = ''
    for row in matrix:
        for num in row:
            key_str += str(num)
    return key_str

def prepare_message_matrix(message, order):
    message = message.replace(" ", "").lower()
    padded_message = message + 'z' * (order - len(message) % order)
    print(f"Modified message for encryption: {padded_message}")
    
    message_matrices = []
    for i in range(0, len(padded_message), order):
        column_matrix = [[ord(char) - ord('a')] for char in padded_message[i:i + order]]
        message_matrices.append(column_matrix)
    
    print("Column matrices of message in numbers:")
    for matrix in message_matrices:
        print(matrix)
    return message_matrices

def matrix_multiply_encrypt(key_matrix, message_matrix):
    result_matrix = [[sum(a * b for a, b in zip(key_row, col)) for col in zip(*message_matrix)] for key_row in key_matrix]
    encrypted_matrix = [['' for _ in range(len(message_matrix[0]))] for _ in range(len(key_matrix))]

    for i in range(len(key_matrix)):
        for j in range(len(message_matrix[0])):
            encrypted_matrix[i][j] = chr((result_matrix[i][j] % 26) + 97)
    return encrypted_matrix


def start_server():
    host = socket.gethostname()
    port = 5001
    server_socket = socket.socket()
    server_socket.bind((host, port))
    server_socket.listen(2)
    conn, address = server_socket.accept()
    print("Connection from:", address)
    
    while True:
        order = int(input("Enter the order of the matrix: "))
        key_matrix = generate_matrix(order)
        key_str = matrix_to_string(key_matrix)
        
        if np.linalg.det(np.array(key_matrix)) != 0:
            print("The matrix is invertible and can be decrypted.")
        else:
            print("The matrix is not invertible and cannot be decrypted.")

        plaintext = input("Enter the message: ")
        if not key_matrix or not plaintext:
            break

        message_matrices = prepare_message_matrix(plaintext, order)
        encrypted_message = ''
        for matrix in message_matrices:
            encrypted_matrix = matrix_multiply_encrypt(key_matrix, matrix)
            for row in encrypted_matrix:
                for char in row:
                    encrypted_message += char
        
        print("Original message:", plaintext)
        print("Encrypted message:", encrypted_message)
        message_to_send = f"{encrypted_message}|{key_str}|{order}"
        print("Message to send:", message_to_send)
        conn.send(message_to_send.encode())
        conn.close()

if __name__ == '__main__':
    start_server()


Receiver:
import socket
import string
import numpy as np

alphabet = string.ascii_lowercase

def create_key_matrix_from_string(key_str, order):
    matrix = []
    for i in range(order):
        row = [int(key_str[i * order + j]) for j in range(order)]
        matrix.append(row)
    return matrix

def modular_inverse(a, m):
    a = a % m
    for x in range(1, m):
        if (a * x) % m == 1:
            return x
    return 1

def apply_modulo(a, m):
    if a > 0:
        return a % m
    else:
        k = (abs(a) // m) + 1
        return apply_modulo(a + k * m, m)

def prepare_message_matrix_for_decryption(ciphertext, order):
    ciphertext = ciphertext.replace(" ", "").lower()
    padded_message = ciphertext + 'z' * (order - len(ciphertext) % order)
    print(f"Modified cipher text for decryption: {padded_message}")
    message_matrices = []
    for i in range(0, len(padded_message), order):
        column_matrix = [[ord(char) - ord('a')] for char in padded_message[i:i + order]]
        message_matrices.append(column_matrix)
    print("Column matrices of cipher text in numbers:")
    for matrix in message_matrices:
        print(matrix)
    return message_matrices
def matrix_multiply_decrypt(key_matrix, message_matrix):
    result_matrix = [[sum(a * b for a, b in zip(key_row, col)) for col in zip(*message_matrix)] for key_row in key_matrix]
    decrypted_matrix = [['' for _ in range(len(message_matrix[0]))] for _ in range(len(key_matrix))]

    for i in range(len(key_matrix)):
        for j in range(len(message_matrix[0])):
            decrypted_matrix[i][j] = chr((result_matrix[i][j] % 26) + 97)
    return decrypted_matrix

def start_client():
    host = socket.gethostname()
    port = 5001
    client_socket = socket.socket()
    client_socket.connect((host, port))
    while True:
        raw_data = client_socket.recv(1024).decode()
        data_parts = raw_data.split("|")
        print(data_parts)
        encrypted_message = data_parts[0]
        key_str = data_parts[1]
        order = int(data_parts[2])
        if not raw_data:
            break
        key_matrix = create_key_matrix_from_string(key_str, order)
        key_matrix_array = np.array(key_matrix)
        determinant = np.linalg.det(key_matrix_array)
        adjugate_matrix = determinant * np.linalg.inv(key_matrix_array)

        if determinant != 0:
            det_inverse = modular_inverse(int(determinant), 26)
            adjugate_matrix = adjugate_matrix.tolist()
            print("Adjugate Matrix before modulo 26 operation:")
            for row in adjugate_matrix:
                print(row)
            print(det_inverse)
            for i in range(len(adjugate_matrix)):
                for j in range(len(adjugate_matrix[i])):
                    adjugate_matrix[i][j] = round(adjugate_matrix[i][j])
                    adjugate_matrix[i][j] = apply_modulo(adjugate_matrix[i][j], 26)
            print("Adjugate Matrix after modulo 26 operation:")
            for row in adjugate_matrix:
                print(row)


Data Encryption Standard (DES)

Client - Server Program ( Encryption at Client, Decryption at Server)
#Server
import socket as sc
hex_dict = {
        '0': '0000', '1': '0001', '2': '0010', '3': '0011',
        '4': '0100', '5': '0101', '6': '0110', '7': '0111',
        '8': '1000', '9': '1001', 'a': '1010', 'b': '1011',
        'c': '1100', 'd': '1101', 'e': '1110', 'f': '1111',
        'A': '1010', 'B': '1011', 'C': '1100', 'D': '1101',
        'E': '1110', 'F': '1111'
    }

mp = {
        "0000": '0', "0001": '1', "0010": '2', "0011": '3',
        "0100": '4', "0101": '5', "0110": '6', "0111": '7',
        "1000": '8', "1001": '9', "1010": 'A', "1011": 'B',
        "1100": 'C', "1101": 'D', "1110": 'E', "1111": 'F'
    }
pc1 = [
        57, 49, 41, 33, 25, 17, 9, 1, 58, 50, 42, 34, 26, 18,
        10, 2, 59, 51, 43, 35, 27, 19, 11, 3, 60, 52, 44, 36,
        63, 55, 47, 39, 31, 23, 15, 7, 62, 54, 46, 38, 30, 22,
        14, 6, 61, 53, 45, 37, 29, 21, 13, 5, 28, 20, 12, 4
    ]
pc2 = [
            14, 17, 11, 24, 1, 5, 3, 28, 15, 6, 21, 10,
            23, 19, 12, 4, 26, 8, 16, 7, 27, 20, 13, 2,
            41, 52, 31, 37, 47, 55, 30, 40, 51, 45, 33, 48,
            44, 49, 39, 56, 34, 53, 46, 42, 50, 36, 29, 32
        ]

ip = [
        58, 50, 42, 34, 26, 18, 10, 2, 60, 52, 44, 36, 28, 20, 12, 4,
        62, 54, 46, 38, 30, 22, 14, 6, 64, 56, 48, 40, 32, 24, 16, 8,
        57, 49, 41, 33, 25, 17, 9, 1, 59, 51, 43, 35, 27, 19, 11, 3,
        61, 53, 45, 37, 29, 21, 13, 5, 63, 55, 47, 39, 31, 23, 15, 7
    ]
expansion = [
        32, 1, 2, 3, 4, 5, 4, 5, 6, 7, 8, 9, 8, 9, 10, 11,
        12, 13, 12, 13, 14, 15, 16, 17, 16, 17, 18, 19, 20, 21, 20, 21,
        22, 23, 24, 25, 24, 25, 26, 27, 28, 29, 28, 29, 30, 31, 32, 1
    ]

sbox = [
        # S1
        [[14, 4, 13, 1, 2, 15, 11, 8, 3, 10, 6, 12, 5, 9, 0, 7],
         [0, 15, 7, 4, 14, 2, 13, 1, 10, 6, 12, 11, 9, 5, 3, 8],
         [4, 1, 14, 8, 13, 6, 2, 11, 15, 12, 9, 7, 3, 10, 5, 0],
         [15, 12, 8, 2, 4, 9, 1, 7, 5, 11, 3, 14, 10, 0, 6, 13]],
        # S2
        [[15, 1, 8, 14, 6, 11, 3, 4, 9, 7, 2, 13, 12, 0, 5, 10],
         [3, 13, 4, 7, 15, 2, 8, 14, 12, 0, 1, 10, 6, 9, 11, 5],
         [0, 14, 7, 11, 10, 4, 13, 1, 5, 8, 12, 6, 9, 3, 2, 15],
         [13, 8, 10, 1, 3, 15, 4, 2, 11, 6, 7, 12, 0, 5, 14, 9]],
        # S3
        [[10, 0, 9, 14, 6, 3, 15, 5, 1, 13, 12, 7, 11, 4, 2, 8],
         [13, 7, 0, 9, 3, 4, 6, 10, 2, 8, 5, 14, 12, 11, 15, 1],
         [13, 6, 4, 9, 8, 15, 3, 0, 11, 1, 2, 12, 5, 10, 14, 7],
         [1, 10, 13, 0, 6, 9, 8, 7, 4, 15, 14, 3, 11, 5, 2, 12]],
        # S4
        [[7, 13, 14, 3, 0, 6, 9, 10, 1, 2, 8, 5, 11, 12, 4, 15],
         [13, 8, 11, 5, 6, 15, 0, 3, 4, 7, 2, 12, 1, 10, 14, 9],
         [10, 6, 9, 0, 12, 11, 7, 13, 15, 1, 3, 14, 5, 2, 8, 4],
         [3, 15, 0, 6, 10, 1, 13, 8, 9, 4, 5, 11, 12, 7, 2, 14]],
        # S5
        [[2, 12, 4, 1, 7, 10, 11, 6, 8, 5, 3, 15, 13, 0, 14, 9],
         [14, 11, 2, 12, 4, 7, 13, 1, 5, 0, 15, 10, 3, 9, 8, 6],
         [4, 2, 1, 11, 10, 13, 7, 8, 15, 9, 12, 5, 6, 3, 0, 14],
         [11, 8, 12, 7, 1, 14, 2, 13, 6, 15, 0, 9, 10, 4, 5, 3]],
        # S6
        [[12, 1, 10, 15, 9, 2, 6, 8, 0, 13, 3, 4, 14, 7, 5, 11],
         [10, 15, 4, 2, 7, 12, 9, 5, 6, 1, 13, 14, 0, 11, 3, 8],
         [9, 14, 15, 5, 2, 8, 12, 3, 7, 0, 4, 10, 1, 13, 11, 6],
         [4, 3, 2, 12, 9, 5, 15, 10, 11, 14, 1, 7, 6, 0, 8, 13]],
        # S7
        [[4, 11, 2, 14, 15, 0, 8, 13, 3, 12, 9, 7, 5, 10, 6, 1],
         [13, 0, 11, 7, 4, 9, 1, 10, 14, 3, 5, 12, 2, 15, 8, 6],
         [1, 4, 11, 13, 12, 3, 7, 14, 10, 15, 6, 8, 0, 5, 9, 2],
         [6, 11, 13, 8, 1, 4, 10, 7, 9, 5, 0, 15, 14, 2, 3, 12]],
        # S8
        [[13, 2, 8, 4, 6, 15, 11, 1, 10, 9, 3, 14, 5, 0, 12, 7],
         [1, 15, 13, 8, 10, 3, 7, 4, 12, 5, 6, 11, 0, 14, 9, 2],
         [7, 11, 4, 1, 9, 12, 14, 2, 0, 6, 10, 13, 15, 3, 5, 8],
         [2, 1, 14, 7, 4, 10, 8, 13, 15, 12, 9, 0, 3, 5, 6, 11]]
    ]
pbox = [
        16, 7, 20, 21, 29, 12, 28, 17,
        1, 15, 23, 26, 5, 18, 31, 10,
        2, 8, 24, 14, 32, 27, 3, 9,
        19, 13, 30, 6, 22, 11, 4, 25
    ]
final_perm = [
        40, 8, 48, 16, 56, 24, 64, 32,
        39, 7, 47, 15, 55, 23, 63, 31,
        38, 6, 46, 14, 54, 22, 62, 30,
        37, 5, 45, 13, 53, 21, 61, 29,
        36, 4, 44, 12, 52, 20, 60, 28,
        35, 3, 43, 11, 51, 19, 59, 27,
        34, 2, 42, 10, 50, 18, 58, 26,
        33, 1, 41, 9, 49, 17, 57, 25
    ]
lst = [1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1]

def get_binary(hex_string):
    binary = ''.join([hex_dict[digit] for digit in hex_string])
    return binary
def bin_hex(binary_string):
    hex_string = ''
    for i in range(0, len(binary_string), 4):
        hex_string += mp[binary_string[i:i+4]]
    return hex_string
def left_shift(bits, times):
    return bits[times:] + bits[:times]

def generate_subkeys(key):
    k = get_binary(key)
    kp = ''.join([k[i-1] for i in pc1])
    C, D = kp[:28], kp[28:]
    subkeys = []
    for i in range(16):
        C, D = left_shift(C, lst[i]), left_shift(D, lst[i])
        Kf = C + D
        subkeys.append(''.join([Kf[i-1] for i in pc2]))
    return subkeys

def xor(a, b):
    return ''.join(['0' if a[i] == b[i] else '1' for i in range(len(a))])

def DES_decrypt(Msg, Cipherkey):
    subkeys = generate_subkeys(Cipherkey)
    subkeys.reverse()  # Reverse the subkeys for decryption

    M = get_binary(Msg)
    ip_result = ''.join([M[i-1] for i in ip])
    L, R = ip_result[:32], ip_result[32:]

    for i in range(16):
        ER = ''.join([R[j-1] for j in expansion])
        ER_XOR = xor(ER, subkeys[i])
        B = [ER_XOR[k:k+6] for k in range(0, 48, 6)]

        out = ''
        for j in range(len(B)):
            row = int(B[j][0] + B[j][5], 2)
            col = int(B[j][1:5], 2)
            val = sbox[j][row][col]
            out += bin(val)[2:].zfill(4)
        p_out = ''.join([out[p-1] for p in pbox])
        L, R = R, xor(L, p_out)
        print("Round -",i+1,bin_hex(L+R))

    rl = R + L
    plain_text = ''.join([rl[final_perm[i]-1] for i in range(64)])
    return bin_hex(plain_text)

host=sc.gethostname()
port=5110
server=sc.socket()
server.bind((host,port))
server.listen(2)
print("Server Listening at port: ",port)
con,add=server.accept()
print("Successfully connected with client")
key=con.recv(1024).decode()
print("Cipher Key: ",key)
while True:
    req=con.recv(1024).decode()
    if not req:
        break
    print("Encrypted Message from Client: ",req)
    print("Actual Message from Client: ",DES_decrypt(req,key))
con.close()    


#Client
import socket as sc
hex_dict = {
        '0': '0000', '1': '0001', '2': '0010', '3': '0011',
        '4': '0100', '5': '0101', '6': '0110', '7': '0111',
        '8': '1000', '9': '1001', 'a': '1010', 'b': '1011',
        'c': '1100', 'd': '1101', 'e': '1110', 'f': '1111',
        'A': '1010', 'B': '1011', 'C': '1100', 'D': '1101',
        'E': '1110', 'F': '1111'
    }
mp = {
        "0000": '0', "0001": '1', "0010": '2', "0011": '3',
        "0100": '4', "0101": '5', "0110": '6', "0111": '7',
        "1000": '8', "1001": '9', "1010": 'A', "1011": 'B',
        "1100": 'C', "1101": 'D', "1110": 'E', "1111": 'F'
    }


pc1 = [
        57, 49, 41, 33, 25, 17, 9, 1, 58, 50, 42, 34, 26, 18,
        10, 2, 59, 51, 43, 35, 27, 19, 11, 3, 60, 52, 44, 36,
        63, 55, 47, 39, 31, 23, 15, 7, 62, 54, 46, 38, 30, 22,
        14, 6, 61, 53, 45, 37, 29, 21, 13, 5, 28, 20, 12, 4
    ]
lst = [1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1]
pc2 = [
            14, 17, 11, 24, 1, 5, 3, 28, 15, 6, 21, 10,
            23, 19, 12, 4, 26, 8, 16, 7, 27, 20, 13, 2,
            41, 52, 31, 37, 47, 55, 30, 40, 51, 45, 33, 48,
            44, 49, 39, 56, 34, 53, 46, 42, 50, 36, 29, 32
        ]
ip = [
        58, 50, 42, 34, 26, 18, 10, 2, 60, 52, 44, 36, 28, 20, 12, 4,
        62, 54, 46, 38, 30, 22, 14, 6, 64, 56, 48, 40, 32, 24, 16, 8,
        57, 49, 41, 33, 25, 17, 9, 1, 59, 51, 43, 35, 27, 19, 11, 3,
        61, 53, 45, 37, 29, 21, 13, 5, 63, 55, 47, 39, 31, 23, 15, 7
    ]
expansion = [
        32, 1, 2, 3, 4, 5, 4, 5, 6, 7, 8, 9, 8, 9, 10, 11,
        12, 13, 12, 13, 14, 15, 16, 17, 16, 17, 18, 19, 20, 21, 20, 21,
        22, 23, 24, 25, 24, 25, 26, 27, 28, 29, 28, 29, 30, 31, 32, 1
    ]
sbox = [
        # S1
        [[14, 4, 13, 1, 2, 15, 11, 8, 3, 10, 6, 12, 5, 9, 0, 7],
         [0, 15, 7, 4, 14, 2, 13, 1, 10, 6, 12, 11, 9, 5, 3, 8],
         [4, 1, 14, 8, 13, 6, 2, 11, 15, 12, 9, 7, 3, 10, 5, 0],
         [15, 12, 8, 2, 4, 9, 1, 7, 5, 11, 3, 14, 10, 0, 6, 13]],
        # S2
        [[15, 1, 8, 14, 6, 11, 3, 4, 9, 7, 2, 13, 12, 0, 5, 10],
         [3, 13, 4, 7, 15, 2, 8, 14, 12, 0, 1, 10, 6, 9, 11, 5],
         [0, 14, 7, 11, 10, 4, 13, 1, 5, 8, 12, 6, 9, 3, 2, 15],
         [13, 8, 10, 1, 3, 15, 4, 2, 11, 6, 7, 12, 0, 5, 14, 9]],
        # S3
        [[10, 0, 9, 14, 6, 3, 15, 5, 1, 13, 12, 7, 11, 4, 2, 8],
         [13, 7, 0, 9, 3, 4, 6, 10, 2, 8, 5, 14, 12, 11, 15, 1],
         [13, 6, 4, 9, 8, 15, 3, 0, 11, 1, 2, 12, 5, 10, 14, 7],
         [1, 10, 13, 0, 6, 9, 8, 7, 4, 15, 14, 3, 11, 5, 2, 12]],
        # S4
        [[7, 13, 14, 3, 0, 6, 9, 10, 1, 2, 8, 5, 11, 12, 4, 15],
         [13, 8, 11, 5, 6, 15, 0, 3, 4, 7, 2, 12, 1, 10, 14, 9],
         [10, 6, 9, 0, 12, 11, 7, 13, 15, 1, 3, 14, 5, 2, 8, 4],
         [3, 15, 0, 6, 10, 1, 13, 8, 9, 4, 5, 11, 12, 7, 2, 14]],
        # S5
        [[2, 12, 4, 1, 7, 10, 11, 6, 8, 5, 3, 15, 13, 0, 14, 9],
         [14, 11, 2, 12, 4, 7, 13, 1, 5, 0, 15, 10, 3, 9, 8, 6],
         [4, 2, 1, 11, 10, 13, 7, 8, 15, 9, 12, 5, 6, 3, 0, 14],
         [11, 8, 12, 7, 1, 14, 2, 13, 6, 15, 0, 9, 10, 4, 5, 3]],
        # S6
        [[12, 1, 10, 15, 9, 2, 6, 8, 0, 13, 3, 4, 14, 7, 5, 11],
         [10, 15, 4, 2, 7, 12, 9, 5, 6, 1, 13, 14, 0, 11, 3, 8],
         [9, 14, 15, 5, 2, 8, 12, 3, 7, 0, 4, 10, 1, 13, 11, 6],
         [4, 3, 2, 12, 9, 5, 15, 10, 11, 14, 1, 7, 6, 0, 8, 13]],
        # S7
        [[4, 11, 2, 14, 15, 0, 8, 13, 3, 12, 9, 7, 5, 10, 6, 1],
         [13, 0, 11, 7, 4, 9, 1, 10, 14, 3, 5, 12, 2, 15, 8, 6],
         [1, 4, 11, 13, 12, 3, 7, 14, 10, 15, 6, 8, 0, 5, 9, 2],
         [6, 11, 13, 8, 1, 4, 10, 7, 9, 5, 0, 15, 14, 2, 3, 12]],
        # S8
        [[13, 2, 8, 4, 6, 15, 11, 1, 10, 9, 3, 14, 5, 0, 12, 7],
         [1, 15, 13, 8, 10, 3, 7, 4, 12, 5, 6, 11, 0, 14, 9, 2],
         [7, 11, 4, 1, 9, 12, 14, 2, 0, 6, 10, 13, 15, 3, 5, 8],
         [2, 1, 14, 7, 4, 10, 8, 13, 15, 12, 9, 0, 3, 5, 6, 11]]
    ]
pbox = [
        16, 7, 20, 21, 29, 12, 28, 17,
        1, 15, 23, 26, 5, 18, 31, 10,
        2, 8, 24, 14, 32, 27, 3, 9,
        19, 13, 30, 6, 22, 11, 4, 25
    ]
final_perm = [
        40, 8, 48, 16, 56, 24, 64, 32,
        39, 7, 47, 15, 55, 23, 63, 31,
        38, 6, 46, 14, 54, 22, 62, 30,
        37, 5, 45, 13, 53, 21, 61, 29,
        36, 4, 44, 12, 52, 20, 60, 28,
        35, 3, 43, 11, 51, 19, 59, 27,
        34, 2, 42, 10, 50, 18, 58, 26,
        33, 1, 41, 9, 49, 17, 57, 25
    ]

def get_binary(hex_string):
    binary = ''.join([hex_dict[digit] for digit in hex_string])
    return binary

def bin_hex(binary_string):
    hex_string = ''
    for i in range(0, len(binary_string), 4):
        hex_string += mp[binary_string[i:i+4]]
    return hex_string

def left_shift(bits, times):
    return bits[times:] + bits[:times]

def generate_subkeys(key):
    k = get_binary(key)
    kp = ''.join([k[i-1] for i in pc1])
    C, D = kp[:28], kp[28:]
    subkeys = []
    for i in range(16):
        C, D = left_shift(C, lst[i]), left_shift(D, lst[i])
        Kf = C + D
        subkeys.append(''.join([Kf[i-1] for i in pc2]))
    return subkeys

def xor(a, b):
    return ''.join(['0' if a[i] == b[i] else '1' for i in range(len(a))])

def DES_encrypt(Msg, Cipherkey):
    subkeys = generate_subkeys(Cipherkey)
    M = get_binary(Msg)
    ip_result = ''.join([M[i-1] for i in ip])
    L, R = ip_result[:32], ip_result[32:]

    for i in range(16):
        ER = ''.join([R[j-1] for j in expansion])
        ER_XOR = xor(ER, subkeys[i])
        B = [ER_XOR[k:k+6] for k in range(0, 48, 6)]
        out = ''

        for j in range(len(B)):
            row = int(B[j][0] + B[j][5], 2)
            col = int(B[j][1:5], 2)
            val = sbox[j][row][col]
            out += bin(val)[2:].zfill(4)

        p_out = ''.join([out[p-1] for p in pbox])
        L, R = R, xor(L, p_out)
        print("Round -",i+1,bin_hex(L+R))

    rl = R + L
    cipher = ''.join([rl[final_perm[i]-1] for i in range(64)])
    return bin_hex(cipher)

host=sc.gethostname()
port=5110
client=sc.socket()
client.connect((host,port))
key=input("Enter Cipher Key: ")
client.send(key.encode())
req=input("Enter Message to Server: ")
while True:
    if req=="Bye":
        break
    encrypt_msg=DES_encrypt(req,key)
    client.send(encrypt_msg.encode())
    print("Encrypted Message sent to Server: ",encrypt_msg)
    req=input("Enter Message to Server: ")
client.close()



Advanced Encryption Standard (AES)

Client - Server Program ( Encryption at Client, Decryption at Server)
#SERVER
import socket as sc
from hashlib import pbkdf2_hmac
import os
from hmac import new as new_hmac, compare_digest

# constants
AES_KEY_SIZE = 16
HMAC_KEY_SIZE = 16
IV_SIZE = 16
SALT_SIZE = 16
HMAC_SIZE = 32

s_box = (
 0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 
0xFE, 0xD7, 0xAB, 0x76,
 0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 
0x9C, 0xA4, 0x72, 0xC0,
 0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 
0x71, 0xD8, 0x31, 0x15,
 0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 
0xEB, 0x27, 0xB2, 0x75,
 0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 
0x29, 0xE3, 0x2F, 0x84,
 0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 
0x4A, 0x4C, 0x58, 0xCF,
 0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 
0x50, 0x3C, 0x9F, 0xA8,
 0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 
0x10, 0xFF, 0xF3, 0xD2,
 0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 
0x64, 0x5D, 0x19, 0x73,
 0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 
0xDE, 0x5E, 0x0B, 0xDB,
 0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 
0x91, 0x95, 0xE4, 0x79,
 0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 
0x65, 0x7A, 0xAE, 0x08,
 0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 
0x4B, 0xBD, 0x8B, 0x8A,
 0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 
0x86, 0xC1, 0x1D, 0x9E,
 0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 
0xCE, 0x55, 0x28, 0xDF,
 0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 
0xB0, 0x54, 0xBB, 0x16,
)

inv_s_box = (
 0x52, 0x09, 0x6A, 0xD5, 0x30, 0x36, 0xA5, 0x38, 0xBF, 0x40, 0xA3, 0x9E, 
0x81, 0xF3, 0xD7, 0xFB,
 0x7C, 0xE3, 0x39, 0x82, 0x9B, 0x2F, 0xFF, 0x87, 0x34, 0x8E, 0x43, 0x44, 
0xC4, 0xDE, 0xE9, 0xCB,
 0x54, 0x7B, 0x94, 0x32, 0xA6, 0xC2, 0x23, 0x3D, 0xEE, 0x4C, 0x95, 0x0B, 
0x42, 0xFA, 0xC3, 0x4E,
 0x08, 0x2E, 0xA1, 0x66, 0x28, 0xD9, 0x24, 0xB2, 0x76, 0x5B, 0xA2, 0x49, 
0x6D, 0x8B, 0xD1, 0x25,
 0x72, 0xF8, 0xF6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xD4, 0xA4, 0x5C, 0xCC, 
0x5D, 0x65, 0xB6, 0x92,
 0x6C, 0x70, 0x48, 0x50, 0xFD, 0xED, 0xB9, 0xDA, 0x5E, 0x15, 0x46, 0x57, 
0xA7, 0x8D, 0x9D, 0x84,
 0x90, 0xD8, 0xAB, 0x00, 0x8C, 0xBC, 0xD3, 0x0A, 0xF7, 0xE4, 0x58, 0x05, 
0xB8, 0xB3, 0x45, 0x06,
 0xD0, 0x2C, 0x1E, 0x8F, 0xCA, 0x3F, 0x0F, 0x02, 0xC1, 0xAF, 0xBD, 0x03, 
0x01, 0x13, 0x8A, 0x6B,
 0x3A, 0x91, 0x11, 0x41, 0x4F, 0x67, 0xDC, 0xEA, 0x97, 0xF2, 0xCF, 0xCE, 
0xF0, 0xB4, 0xE6, 0x73,
 0x96, 0xAC, 0x74, 0x22, 0xE7, 0xAD, 0x35, 0x85, 0xE2, 0xF9, 0x37, 0xE8, 
0x1C, 0x75, 0xDF, 0x6E,
 0x47, 0xF1, 0x1A, 0x71, 0x1D, 0x29, 0xC5, 0x89, 0x6F, 0xB7, 0x62, 0x0E, 
0xAA, 0x18, 0xBE, 0x1B,
 0xFC, 0x56, 0x3E, 0x4B, 0xC6, 0xD2, 0x79, 0x20, 0x9A, 0xDB, 0xC0, 0xFE, 
0x78, 0xCD, 0x5A, 0xF4,
 0x1F, 0xDD, 0xA8, 0x33, 0x88, 0x07, 0xC7, 0x31, 0xB1, 0x12, 0x10, 0x59, 
0x27, 0x80, 0xEC, 0x5F,
 0x60, 0x51, 0x7F, 0xA9, 0x19, 0xB5, 0x4A, 0x0D, 0x2D, 0xE5, 0x7A, 0x9F, 
0x93, 0xC9, 0x9C, 0xEF,
 0xA0, 0xE0, 0x3B, 0x4D, 0xAE, 0x2A, 0xF5, 0xB0, 0xC8, 0xEB, 0xBB, 0x3C, 
0x83, 0x53, 0x99, 0x61,
 0x17, 0x2B, 0x04, 0x7E, 0xBA, 0x77, 0xD6, 0x26, 0xE1, 0x69, 0x14, 0x63, 
0x55, 0x21, 0x0C, 0x7D,
)

def sub_bytes(s):
    for i in range(4):
        for j in range(4):
            s[i][j] = s_box[s[i][j]]

def inv_sub_bytes(s):
    for i in range(4):
        for j in range(4):
            s[i][j] = inv_s_box[s[i][j]]

def shift_rows(s):
    s[0][1], s[1][1], s[2][1], s[3][1] = s[1][1], s[2][1], s[3][1], s[0][1]
    s[0][2], s[1][2], s[2][2], s[3][2] = s[2][2], s[3][2], s[0][2], s[1][2]
    s[0][3], s[1][3], s[2][3], s[3][3] = s[3][3], s[0][3], s[1][3], s[2][3]

def inv_shift_rows(s):
    s[0][1], s[1][1], s[2][1], s[3][1] = s[3][1], s[0][1], s[1][1], s[2][1]
    s[0][2], s[1][2], s[2][2], s[3][2] = s[2][2], s[3][2], s[0][2], s[1][2]
    s[0][3], s[1][3], s[2][3], s[3][3] = s[1][3], s[2][3], s[3][3], s[0][3]

def add_round_key(s, k):
    for i in range(4):
        for j in range(4):
            s[i][j] ^= k[i][j]

xtime = lambda a: (((a << 1) ^ 0x1B) & 0xFF) if (a & 0x80) else (a << 1)

def mix_single_column(a):
    t = a[0] ^ a[1] ^ a[2] ^ a[3]
    u = a[0]
    a[0] ^= t ^ xtime(a[0] ^ a[1])
    a[1] ^= t ^ xtime(a[1] ^ a[2])
    a[2] ^= t ^ xtime(a[2] ^ a[3])
    a[3] ^= t ^ xtime(a[3] ^ u)


def mix_columns(s):
    for i in range(4):
        mix_single_column(s[i])

def inv_mix_columns(s):
 
    for i in range(4):
        u = xtime(xtime(s[i][0] ^ s[i][2]))
        v = xtime(xtime(s[i][1] ^ s[i][3]))
        s[i][0] ^= u
        s[i][1] ^= v
        s[i][2] ^= u
        s[i][3] ^= v
    mix_columns(s)

r_con = (
 0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40,
 0x80, 0x1B, 0x36, 0x6C, 0xD8, 0xAB, 0x4D, 0x9A,
 0x2F, 0x5E, 0xBC, 0x63, 0xC6, 0x97, 0x35, 0x6A,
 0xD4, 0xB3, 0x7D, 0xFA, 0xEF, 0xC5, 0x91, 0x39,
)

def bytes2matrix(text):
    """ Converts a 16-byte array into a 4x4 matrix. """
    return [list(text[i:i + 4]) for i in range(0, len(text), 4)]

def matrix2bytes(matrix):
    """ Converts a 4x4 matrix into a 16-byte array. """
    return bytes(sum(matrix, []))

def xor_bytes(a, b):
    """ Returns a new byte array with the elements xor'ed. """
    return bytes(i ^ j for i, j in zip(a, b))

def inc_bytes(a):
    """ Returns a new byte array with the value increment by 1 """
    out = list(a)
    for i in reversed(range(len(out))):
        if out[i] == 0xFF:
            out[i] = 0
        else:
            out[i] += 1
            break
    return bytes(out)

def pad(plaintext):
    """
    Pads the given plaintext with PKCS#7 padding to a multiple of 16 bytes.
    Note that if the plaintext size is a multiple of 16,
    a whole block will be added.
    """
    padding_len = 16 - (len(plaintext) % 16)
    padding = bytes([padding_len] * padding_len)
    return plaintext + padding

def unpad(plaintext):
    """
    Removes a PKCS#7 padding, returning the unpadded text and ensuring the
    padding was correct.
    """
    padding_len = plaintext[-1]
    assert padding_len > 0
    message, padding = plaintext[:-padding_len], plaintext[-padding_len:]
    assert all(p == padding_len for p in padding)
    return message

def split_blocks(message, block_size=16, require_padding=True):
    assert len(message) % block_size == 0 or not require_padding
    return [message[i:i + 16] for i in range(0, len(message), block_size)]

class AES:
    """
    Class for AES-128 encryption with CBC mode and PKCS#7.
    This is a raw implementation of AES, without key stretching or IV
    management. Unless you need that, please use `encrypt` and `decrypt`.
    """
    rounds_by_key_size = {16: 10, 24: 12, 32: 14}
    def __init__(self, master_key):
        """
        Initializes the object with a given key.
        """
        assert len(master_key) in AES.rounds_by_key_size
        self.n_rounds = AES.rounds_by_key_size[len(master_key)]
        self._key_matrices = self._expand_key(master_key)


    def _expand_key(self, master_key):
        """
        Expands and returns a list of key matrices for the given 
        master_key.
        """
        # Initialize round keys with raw key material.
        key_columns = bytes2matrix(master_key)
        iteration_size = len(master_key) // 4
        i = 1
        while len(key_columns) < (self.n_rounds + 1) * 4:
            # Copy previous word.
            word = list(key_columns[-1])
            # Perform schedule_core once every "row".
            if len(key_columns) % iteration_size == 0:
                # Circular shift.
                word.append(word.pop(0))
                # Map to S-BOX.
                word = [s_box[b] for b in word]
                # XOR with first byte of R-CON, since the others bytes of R-CON are 0.
                word[0] ^= r_con[i]
                i += 1
            elif len(master_key) == 32 and len(key_columns) % iteration_size == 4:
                # Run word through S-box in the fourth iteration when using a 256-bit key.
                word = [s_box[b] for b in word]
            # XOR with equivalent word from previous iteration.
            word = xor_bytes(word, key_columns[-iteration_size])
            key_columns.append(word)

        # Group key words in 4x4 byte matrices.
        return [key_columns[4 * i: 4 * (i + 1)] for i in range(len(key_columns) // 4)]

    def encrypt_block(self, plaintext):
        """
        Encrypts a single block of 16 byte long plaintext.
        """
        assert len(plaintext) == 16
        plain_state = bytes2matrix(plaintext)
        add_round_key(plain_state, self._key_matrices[0])
        for i in range(1, self.n_rounds):
            sub_bytes(plain_state)
            shift_rows(plain_state)
            mix_columns(plain_state)
            add_round_key(plain_state, self._key_matrices[i])
        sub_bytes(plain_state)
        shift_rows(plain_state)
        add_round_key(plain_state, self._key_matrices[-1])
        
        return matrix2bytes(plain_state)

    def decrypt_block(self, ciphertext):
        """
        Decrypts a single block of 16 byte long ciphertext.
        """
        assert len(ciphertext) == 16
        cipher_state = bytes2matrix(ciphertext)
        add_round_key(cipher_state, self._key_matrices[-1])
        inv_shift_rows(cipher_state)
        inv_sub_bytes(cipher_state)
        for i in range(self.n_rounds - 1, 0, -1):
            add_round_key(cipher_state, self._key_matrices[i])
            inv_mix_columns(cipher_state)
            inv_shift_rows(cipher_state)
            inv_sub_bytes(cipher_state)
        add_round_key(cipher_state, self._key_matrices[0])
        
        return matrix2bytes(cipher_state)

    def encrypt_cbc(self, plaintext, iv):
        """
        Encrypts `plaintext` using CBC mode and PKCS#7 padding, with the 
        given
        initialization vector (iv).
        """
        assert len(iv) == 16
        plaintext = pad(plaintext)
        blocks = []
        previous = iv
        for plaintext_block in split_blocks(plaintext):
            # CBC mode encrypt: encrypt(plaintext_block XOR previous)
            block = self.encrypt_block(xor_bytes(plaintext_block, previous))
            blocks.append(block)
            previous = block
        return b''.join(blocks)



    def decrypt_cbc(self, ciphertext, iv):
        """
        Decrypts `ciphertext` using CBC mode and PKCS#7 padding, with the 
        given
        initialization vector (iv).
        """
        assert len(iv) == 16
        blocks = []
        previous = iv
        for ciphertext_block in split_blocks(ciphertext):
            # CBC mode decrypt: previous XOR decrypt(ciphertext)
            blocks.append(xor_bytes(previous, 
            self.decrypt_block(ciphertext_block)))
            previous = ciphertext_block
        return unpad(b''.join(blocks))

def get_key_iv(password, salt, workload=100000):
    """
    Stretches the password and extracts an AES key, an HMAC key and an AES
    initialization vector.
    """
    stretched = pbkdf2_hmac('sha256', password, salt, workload, AES_KEY_SIZE + IV_SIZE + HMAC_KEY_SIZE)
    print(f"Stretched length: {len(stretched)}")
    print(f"Stretched content: {stretched.hex()}")
    
    if len(stretched) < AES_KEY_SIZE + IV_SIZE + HMAC_KEY_SIZE:
        raise ValueError("Stretched key material is shorter than expected")

    aes_key, stretched = stretched[:AES_KEY_SIZE], stretched[AES_KEY_SIZE:]
    hmac_key, stretched = stretched[:HMAC_KEY_SIZE], stretched[HMAC_KEY_SIZE:]
    iv = stretched[:IV_SIZE]
    return aes_key, hmac_key, iv

def decrypt(key, ciphertext, workload=100000):
    """
    Decrypts `ciphertext` with `key` using AES-128, an HMAC to verify 
    integrity,
    and PBKDF2 to stretch the given key.
    The exact algorithm is specified in the module docstring.
    """
    assert len(ciphertext) % 16 == 0, "Ciphertext must be made of full 16-byte blocks."
    assert len(ciphertext) >= 32, """
    Ciphertext must be at least 32 bytes long (16 byte salt + 16 byte 
    block). To
    encrypt or decrypt single blocks use 
    `AES(key).decrypt_block(ciphertext)`.
    """
    if isinstance(key, str):
        key = key.encode('utf-8')
    hmac, ciphertext = ciphertext[:HMAC_SIZE], ciphertext[HMAC_SIZE:]
    salt, ciphertext = ciphertext[:SALT_SIZE], ciphertext[SALT_SIZE:]
    key, hmac_key, iv = get_key_iv(key, salt, workload)
    expected_hmac = new_hmac(hmac_key, salt + ciphertext, 
    'sha256').digest()
    assert compare_digest(hmac, expected_hmac), 'Ciphertext corrupted or tampered.'
    return AES(key).decrypt_cbc(ciphertext, iv)


host=sc.gethostname()
port=5110
server=sc.socket()
server.bind((host,port))
server.listen(2)
print("Server Listening at port: ",port)
con,add=server.accept()
print("Successfully connected with client")

key = b'\r^\xf4K\x86\xf5\xd7\x92\xe8\x86\x11\x02@\xdf\xbd\x00'
print("Cipher Key: ",key)

while True:
    req=con.recv(1024)
    if not req:
        break
    print("Encrypted Message from Client: ",req)
    print("Actual Message from Client: ",decrypt(key=key, ciphertext=req))
con.close()   






#Client
import socket as sc
from hashlib import pbkdf2_hmac
import os
from hmac import new as new_hmac, compare_digest
# constants
AES_KEY_SIZE = 16
HMAC_KEY_SIZE = 16
IV_SIZE = 16
SALT_SIZE = 16
HMAC_SIZE = 32
s_box = (
 0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 
0xFE, 0xD7, 0xAB, 0x76,
 0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 
0x9C, 0xA4, 0x72, 0xC0,
 0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 
0x71, 0xD8, 0x31, 0x15,
 0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 
0xEB, 0x27, 0xB2, 0x75,
 0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 
0x29, 0xE3, 0x2F, 0x84,
 0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 
0x4A, 0x4C, 0x58, 0xCF,
 0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 
0x50, 0x3C, 0x9F, 0xA8,
 0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 
0x10, 0xFF, 0xF3, 0xD2,
 0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 
0x64, 0x5D, 0x19, 0x73,
 0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 
0xDE, 0x5E, 0x0B, 0xDB,
 0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 
0x91, 0x95, 0xE4, 0x79,
 0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 
0x65, 0x7A, 0xAE, 0x08,
 0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 
0x4B, 0xBD, 0x8B, 0x8A,
 0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 
0x86, 0xC1, 0x1D, 0x9E,
 0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 
0xCE, 0x55, 0x28, 0xDF,
 0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 
0xB0, 0x54, 0xBB, 0x16,
)
inv_s_box = (
 0x52, 0x09, 0x6A, 0xD5, 0x30, 0x36, 0xA5, 0x38, 0xBF, 0x40, 0xA3, 0x9E, 
0x81, 0xF3, 0xD7, 0xFB,
 0x7C, 0xE3, 0x39, 0x82, 0x9B, 0x2F, 0xFF, 0x87, 0x34, 0x8E, 0x43, 0x44, 
0xC4, 0xDE, 0xE9, 0xCB,
 0x54, 0x7B, 0x94, 0x32, 0xA6, 0xC2, 0x23, 0x3D, 0xEE, 0x4C, 0x95, 0x0B, 
0x42, 0xFA, 0xC3, 0x4E,
 0x08, 0x2E, 0xA1, 0x66, 0x28, 0xD9, 0x24, 0xB2, 0x76, 0x5B, 0xA2, 0x49, 
0x6D, 0x8B, 0xD1, 0x25,
 0x72, 0xF8, 0xF6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xD4, 0xA4, 0x5C, 0xCC, 
0x5D, 0x65, 0xB6, 0x92,
 0x6C, 0x70, 0x48, 0x50, 0xFD, 0xED, 0xB9, 0xDA, 0x5E, 0x15, 0x46, 0x57, 
0xA7, 0x8D, 0x9D, 0x84,
 0x90, 0xD8, 0xAB, 0x00, 0x8C, 0xBC, 0xD3, 0x0A, 0xF7, 0xE4, 0x58, 0x05, 
0xB8, 0xB3, 0x45, 0x06,
 0xD0, 0x2C, 0x1E, 0x8F, 0xCA, 0x3F, 0x0F, 0x02, 0xC1, 0xAF, 0xBD, 0x03, 
0x01, 0x13, 0x8A, 0x6B,
 0x3A, 0x91, 0x11, 0x41, 0x4F, 0x67, 0xDC, 0xEA, 0x97, 0xF2, 0xCF, 0xCE, 
0xF0, 0xB4, 0xE6, 0x73,
 0x96, 0xAC, 0x74, 0x22, 0xE7, 0xAD, 0x35, 0x85, 0xE2, 0xF9, 0x37, 0xE8, 
0x1C, 0x75, 0xDF, 0x6E,
 0x47, 0xF1, 0x1A, 0x71, 0x1D, 0x29, 0xC5, 0x89, 0x6F, 0xB7, 0x62, 0x0E, 
0xAA, 0x18, 0xBE, 0x1B,
 0xFC, 0x56, 0x3E, 0x4B, 0xC6, 0xD2, 0x79, 0x20, 0x9A, 0xDB, 0xC0, 0xFE, 
0x78, 0xCD, 0x5A, 0xF4,
 0x1F, 0xDD, 0xA8, 0x33, 0x88, 0x07, 0xC7, 0x31, 0xB1, 0x12, 0x10, 0x59, 
0x27, 0x80, 0xEC, 0x5F,
 0x60, 0x51, 0x7F, 0xA9, 0x19, 0xB5, 0x4A, 0x0D, 0x2D, 0xE5, 0x7A, 0x9F, 
0x93, 0xC9, 0x9C, 0xEF,
 0xA0, 0xE0, 0x3B, 0x4D, 0xAE, 0x2A, 0xF5, 0xB0, 0xC8, 0xEB, 0xBB, 0x3C, 
0x83, 0x53, 0x99, 0x61,
 0x17, 0x2B, 0x04, 0x7E, 0xBA, 0x77, 0xD6, 0x26, 0xE1, 0x69, 0x14, 0x63, 
0x55, 0x21, 0x0C, 0x7D,
)

def sub_bytes(s):
    for i in range(4):
        for j in range(4):
            s[i][j] = s_box[s[i][j]]

def inv_sub_bytes(s):
    for i in range(4):
        for j in range(4):
            s[i][j] = inv_s_box[s[i][j]]

def shift_rows(s):
    s[0][1], s[1][1], s[2][1], s[3][1] = s[1][1], s[2][1], s[3][1], s[0][1]
    s[0][2], s[1][2], s[2][2], s[3][2] = s[2][2], s[3][2], s[0][2], s[1][2]
    s[0][3], s[1][3], s[2][3], s[3][3] = s[3][3], s[0][3], s[1][3], s[2][3]

def inv_shift_rows(s):
    s[0][1], s[1][1], s[2][1], s[3][1] = s[3][1], s[0][1], s[1][1], s[2][1]
    s[0][2], s[1][2], s[2][2], s[3][2] = s[2][2], s[3][2], s[0][2], s[1][2]
    s[0][3], s[1][3], s[2][3], s[3][3] = s[1][3], s[2][3], s[3][3], s[0][3]

def add_round_key(s, k):
    for i in range(4):
        for j in range(4):
            s[i][j] ^= k[i][j]

xtime = lambda a: (((a << 1) ^ 0x1B) & 0xFF) if (a & 0x80) else (a << 1)

def mix_single_column(a):
    
    t = a[0] ^ a[1] ^ a[2] ^ a[3]
    u = a[0]
    a[0] ^= t ^ xtime(a[0] ^ a[1])
    a[1] ^= t ^ xtime(a[1] ^ a[2])
    a[2] ^= t ^ xtime(a[2] ^ a[3])
    a[3] ^= t ^ xtime(a[3] ^ u)

def mix_columns(s):
    for i in range(4):
        mix_single_column(s[i])

def inv_mix_columns(s):
 
    for i in range(4):
        u = xtime(xtime(s[i][0] ^ s[i][2]))
        v = xtime(xtime(s[i][1] ^ s[i][3]))
        s[i][0] ^= u
        s[i][1] ^= v
        s[i][2] ^= u
        s[i][3] ^= v

    mix_columns(s)

r_con = (
 0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40,
 0x80, 0x1B, 0x36, 0x6C, 0xD8, 0xAB, 0x4D, 0x9A,
 0x2F, 0x5E, 0xBC, 0x63, 0xC6, 0x97, 0x35, 0x6A,
 0xD4, 0xB3, 0x7D, 0xFA, 0xEF, 0xC5, 0x91, 0x39,
)

def bytes2matrix(text):
    """ Converts a 16-byte array into a 4x4 matrix. """
    return [list(text[i:i + 4]) for i in range(0, len(text), 4)]

def matrix2bytes(matrix):
    """ Converts a 4x4 matrix into a 16-byte array. """
    return bytes(sum(matrix, []))

def xor_bytes(a, b):
    """ Returns a new byte array with the elements xor'ed. """
    return bytes(i ^ j for i, j in zip(a, b))

def inc_bytes(a):
    """ Returns a new byte array with the value increment by 1 """
    out = list(a)
    for i in reversed(range(len(out))):
        if out[i] == 0xFF:
            out[i] = 0
        else:
            out[i] += 1
            break
    return bytes(out)

def pad(plaintext):
     """
     Pads the given plaintext with PKCS#7 padding to a multiple of 16 bytes.
     Note that if the plaintext size is a multiple of 16,
     a whole block will be added.
     """
     padding_len = 16 - (len(plaintext) % 16)
     padding = bytes([padding_len] * padding_len)
     return plaintext + padding

def unpad(plaintext):
    """
    Removes a PKCS#7 padding, returning the unpadded text and ensuring the
    padding was correct.
    """
    padding_len = plaintext[-1]
    assert padding_len > 0
    message, padding = plaintext[:-padding_len], plaintext[-padding_len:]
    assert all(p == padding_len for p in padding)
    return message

def split_blocks(message, block_size=16, require_padding=True):
    assert len(message) % block_size == 0 or not require_padding
    return [message[i:i + 16] for i in range(0, len(message), block_size)]

def get_key_iv(password, salt, workload=100000):
    """
    Stretches the password and extracts an AES key, an HMAC key and an AES
    initialization vector.
    """
    stretched = pbkdf2_hmac('sha256', password, salt, workload, AES_KEY_SIZE + IV_SIZE + HMAC_KEY_SIZE)
    print(f"Stretched length: {len(stretched)}")
    print(f"Stretched content: {stretched.hex()}")
    
    if len(stretched) < AES_KEY_SIZE + IV_SIZE + HMAC_KEY_SIZE:
        raise ValueError("Stretched key material is shorter than expected")

    aes_key, stretched = stretched[:AES_KEY_SIZE], stretched[AES_KEY_SIZE:]
    hmac_key, stretched = stretched[:HMAC_KEY_SIZE], stretched[HMAC_KEY_SIZE:]
    iv = stretched[:IV_SIZE]
    return aes_key, hmac_key, iv


class AES:
    """
    Class for AES-128 encryption with CBC mode and PKCS#7.
    This is a raw implementation of AES, without key stretching or IV
    management. Unless you need that, please use `encrypt` and `decrypt`.
    """
    rounds_by_key_size = {16: 10, 24: 12, 32: 14}
    
    def __init__(self, master_key):
        """
        Initializes the object with a given key.
        """
        assert len(master_key) in AES.rounds_by_key_size
        self.n_rounds = AES.rounds_by_key_size[len(master_key)]
        self._key_matrices = self._expand_key(master_key)
    
    def _expand_key(self, master_key):
        """
        Expands and returns a list of key matrices for the given 
        master_key.
        """
        # Initialize round keys with raw key material.
        key_columns = bytes2matrix(master_key)
        iteration_size = len(master_key) // 4
        i = 1
        while len(key_columns) < (self.n_rounds + 1) * 4:
            # Copy previous word.
            word = list(key_columns[-1])
            # Perform schedule_core once every "row".
            if len(key_columns) % iteration_size == 0:
                # Circular shift.
                word.append(word.pop(0))
                # Map to S-BOX.
                word = [s_box[b] for b in word]
                # XOR with first byte of R-CON, since the others bytes of R-CON are 0.
                word[0] ^= r_con[i]
                i += 1
            elif len(master_key) == 32 and len(key_columns) % iteration_size == 4:
                # Run word through S-box in the fourth iteration when using a 256-bit key.
                word = [s_box[b] for b in word]

            # XOR with equivalent word from previous iteration.
            word = xor_bytes(word, key_columns[-iteration_size])
            key_columns.append(word)
            # Group key words in 4x4 byte matrices.
        return [key_columns[4 * i: 4 * (i + 1)] for i in range(len(key_columns) // 4)]
    
    def encrypt_block(self, plaintext):
        assert len(plaintext) == 16
        plain_state = bytes2matrix(plaintext)
        add_round_key(plain_state, self._key_matrices[0])
        for i in range(1, self.n_rounds):
            sub_bytes(plain_state)
            shift_rows(plain_state)
            mix_columns(plain_state)
            add_round_key(plain_state, self._key_matrices[i])
        sub_bytes(plain_state)
        shift_rows(plain_state)
        add_round_key(plain_state, self._key_matrices[-1])
        return matrix2bytes(plain_state)
    
    def encrypt_cbc(self, plaintext, iv):
        assert len(iv) == 16
        plaintext = pad(plaintext)
        blocks = []
        previous = iv
        for plaintext_block in split_blocks(plaintext):
            # CBC mode encrypt: encrypt(plaintext_block XOR previous)
            block = self.encrypt_block(xor_bytes(plaintext_block, previous))
            blocks.append(block)
            previous = block
        return b''.join(blocks)
    
def encrypt(key, plaintext, workload=100000):
    """
    Encrypts `plaintext` with `key` using AES-128, an HMAC to verify 
    integrity,
    and PBKDF2 to stretch the given key.
    The exact algorithm is specified in the module docstring.
    """

    if isinstance(key, str):
        key = key.encode('utf-8')
    if isinstance(plaintext, str):
        plaintext = plaintext.encode('utf-8')
    salt = os.urandom(SALT_SIZE)
    key, hmac_key, iv = get_key_iv(key, salt, workload)
    ciphertext = AES(key).encrypt_cbc(plaintext, iv)
    hmac = new_hmac(hmac_key, salt + ciphertext, 'sha256').digest()
    assert len(hmac) == HMAC_SIZE
    return hmac + salt + ciphertext

host=sc.gethostname()
port=5110
client=sc.socket()
client.connect((host,port))
key = b'\r^\xf4K\x86\xf5\xd7\x92\xe8\x86\x11\x02@\xdf\xbd\x00'
print("Cipher Key: ",key)
req=input("Enter Message to Server: ")
while True:
    if req=="Bye":
        break
    encrypt_msg= encrypt(key=key, plaintext=req)
    client.send(encrypt_msg)
    print("Encrypted Message sent to Server: ",encrypt_msg)
    req=input("Enter Message to Server: ")
client.close()     



Rivest-Shamir-Adleman (RSA) Algorithm

#SERVER
import socket
import random
import math
def is_prime(n, k=5):
    if n < 2:
        return False
    for p in [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]:
        if n % p == 0:
            return n == p
    s, d = 0, n - 1
    while d % 2 == 0:
        s, d = s + 1, d // 2
    for _ in range(k):
        a = random.randrange(2, n - 1)
        x = pow(a, d, n)
        if x != 1 and x != n - 1:
            for _ in range(s - 1):
                x = pow(x, 2, n)
                if x == n - 1:
                    break
            else:
                return False
    return True

def generate_prime(bits):
    while True:
        n = random.getrandbits(bits)
        if n % 2 != 0 and is_prime(n):
            return n

def mod_inverse(a, m):
    def egcd(a, b):
        if a == 0:
            return (b, 0, 1)
        else:
            g, y, x = egcd(b % a, a)
            return (g, x - (b // a) * y, y)
    
    g, x, _ = egcd(a, m)
    if g != 1:
        raise Exception('Modular inverse does not exist')
    else:
        return x % m

# Generate RSA key pair
p = generate_prime(1024)
q = generate_prime(1024)
n = p * q
phi = (p - 1) * (q - 1)
e = 65537
d = mod_inverse(e, phi)

# Set up server
server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
server_socket.bind(('localhost', 12345))
server_socket.listen(1)
print("Server is listening...")
client_socket, addr = server_socket.accept()
print(f"Connection from {addr}")

# Send public key to client
public_key = f"{n},{e}".encode()
client_socket.send(public_key)
# Receive encrypted message from client
encrypted_message = int(client_socket.recv(1024).decode())

# Decrypt message
decrypted_message = pow(encrypted_message, d, n)
decrypted_text = decrypted_message.to_bytes(
    (decrypted_message.bit_length() + 7) // 8, byteorder='big'
).decode()
print("\nServer Output:")
print(f"p value: {p}")
print(f"q value: {q}")
print(f"n = p * q: {n}")
print(f"phi(n): {phi}")
print(f"e: {e}")
print(f"d: {d}")
print(f"Encrypted text: {encrypted_message}")
print(f"Decrypted text: {decrypted_text}")

server_socket.close()
#Client
import socket

def encrypt(message, e, n):
    m = int.from_bytes(message.encode(), byteorder='big')
    return pow(m, e, n)

# Set up client
client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
client_socket.connect(('localhost', 12345))

# Receive public key from server
public_key_data = client_socket.recv(1024).decode()
n, e = map(int, public_key_data.split(','))

# Get message from user
message = input("Enter the message to encrypt: ")

# Encrypt message
encrypted_message = encrypt(message, e, n)

# Send encrypted message to server
client_socket.send(str(encrypted_message).encode())

print("Message sent to server.")
client_socket.close()




Assignment 5: Implementation of Man in the middle attack of Diffie Hellman

Aim: Implement the man in the attack in Diffie Hellman Key Exchange

Code:
Sender:

import socket
# Diffie-Hellman parameters
q = 23  # Prime number
a = 5   # Primitive root modulo q

# Alice's private key
alice_private_key = int(input("Alice: Enter your private key: "))
alice_public_key = (a ** alice_private_key) % q
# Connect to Mallory (MITM attacker)
alice_socket = socket.socket()
alice_socket.connect(('127.0.0.1', 17493))
alice_socket.send(str(alice_public_key).encode())
print("Alice's public key sent to Mallory.")

# Receive what Alice believes is Bob's public key
mallory_public_key = int(alice_socket.recv(1024).decode())

# Compute the shared key
alice_shared_key = (mallory_public_key ** alice_private_key) % q
print("Alice's computed shared key:", alice_shared_key)
Man In The Middle (Attacker):
import socket
import time

# Diffie-Hellman parameters
q = 23
a = 5

# Mallory's private keys
mallory_private_key_alice = int(input("Mallory: Enter your private key for Alice: "))
mallory_private_key_bob = int(input("Mallory: Enter your private key for Bob: "))

# Mallory's public keys
mallory_public_key_alice = (a ** mallory_private_key_alice) % q
mallory_public_key_bob = (a ** mallory_private_key_bob) % q

# Setting up server to listen for Alice
mallory_socket_alice = socket.socket()
mallory_socket_alice.bind(('', 17493))
mallory_socket_alice.listen(1)

# Intercept Alice's public key
conn_alice, addr_alice = mallory_socket_alice.accept()
alice_public_key = int(conn_alice.recv(1024).decode())
print("Mallory intercepted Alice's public key:", alice_public_key)

# Send Mallory's public key to Alice
conn_alice.send(str(mallory_public_key_alice).encode())
conn_alice.close()

# Compute shared key with Alice
mallory_shared_key_alice = (alice_public_key ** mallory_private_key_alice) % q
print("Mallory's shared key with Alice:", mallory_shared_key_alice)

# Setting up connection to Bob with retry
connected = False
while not connected:
    try:
        mallory_socket_bob = socket.socket()
        mallory_socket_bob.connect(('127.0.0.1', 23579))
        connected = True
    except ConnectionRefusedError:
        print("Waiting for Bob to be ready...")
        time.sleep(2)  # Wait for 2 seconds before retrying

# Send Mallory's public key to Bob
mallory_socket_bob.send(str(mallory_public_key_bob).encode())

# Intercept Bob's public key
bob_public_key = int(mallory_socket_bob.recv(1024).decode())
print("Mallory intercepted Bob's public key:", bob_public_key)

# Compute shared key with Bob
mallory_shared_key_bob = (bob_public_key ** mallory_private_key_bob) % q
print("Mallory's shared key with Bob:", mallory_shared_key_bob)

mallory_socket_bob.close()

Receiver:
import socket

# Diffie-Hellman parameters
q = 23
a = 5

# Bob's private key
bob_private_key = int(input("Bob: Enter your private key: "))
bob_public_key = (a ** bob_private_key) % q

# Setting up server to listen for Mallory
bob_socket = socket.socket()
bob_socket.bind(('', 23579))
bob_socket.listen(1)

# Receive what Bob believes is Alice's public key
conn_bob, addr_bob = bob_socket.accept()
mallory_public_key = int(conn_bob.recv(1024).decode())

# Compute the shared key
bob_shared_key = (mallory_public_key ** bob_private_key) % q
print("Bob's computed shared key:", bob_shared_key)

# Send Bob's public key back to Mallory
conn_bob.send(str(bob_public_key).encode())
conn_bob.close()




Assignment 6: Implementation of MD5

import struct
import math

# MD5 Constants (these are constant values used in MD5 transformation)
S = [
    7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22,
    5, 9, 14, 20, 5, 9, 14, 20, 5, 9, 14, 20, 5, 9, 14, 20,
    4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23,
    6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21
]

K = [int(abs(math.sin(i + 1)) * (2 ** 32)) & 0xFFFFFFFF for i in range(64)]

# Helper function to left rotate x by n bits
def left_rotate(x, n):
    return ((x << n) | (x >> (32 - n))) & 0xFFFFFFFF


# Padding function to make message a multiple of 512 bits (64 bytes)
def pad_message(message):
    original_len_in_bits = len(message) * 8
    message += b'\x80'  # Append the bit '1'
    while len(message) % 64 != 56:
        message += b'\x00'  # Append '0' bits until the message is 448 bits mod 512
    message += struct.pack('<Q', original_len_in_bits)  
# Append the original length of message
    return message

# Main MD5 function
def md5(message):
    message = pad_message(message)

    # Initial hash values (little-endian)
    A = 0x67452301
    B = 0xEFCDAB89
    C = 0x98BADCFE
    D = 0x10325476

    for i in range(0, len(message), 64):
        block = message[i:i+64]
        M = struct.unpack('<16I', block)

        # Initialize hash value for this chunk
        a, b, c, d = A, B, C, D


        # Main loop (64 operations, divided into 4 rounds)
        for j in range(64):
            if 0 <= j <= 15:
                F = (b & c) | (~b & d)
                g = j
            elif 16 <= j <= 31:
                F = (d & b) | (~d & c)
                g = (5 * j + 1) % 16
            elif 32 <= j <= 47:
                F = b ^ c ^ d
                g = (3 * j + 5) % 16
            elif 48 <= j <= 63:
                F = c ^ (b | ~d)
                g = (7 * j) % 16

            F = (F + a + K[j] + M[g]) & 0xFFFFFFFF
            a = d
            d = c
            c = b
            b = (b + left_rotate(F, S[j])) & 0xFFFFFFFF

            # Print the round number and intermediate block values
            if j % 16 == 0:
                print(f"Round {j//16 + 1}, Block {i//64 + 1}: A = {a:08x}, B = {b:08x}, C = {c:08x}, D = {d:08x}")



        # Add this chunk's hash to result so far
        A = (A + a) & 0xFFFFFFFF
        B = (B + b) & 0xFFFFFFFF
        C = (C + c) & 0xFFFFFFFF
        D = (D + d) & 0xFFFFFFFF

    # Final hash value (little-endian)
    return struct.pack('<4I', A, B, C, D).hex()

# MD5 implementation
message = b"hello world"
print("Message:",message)
print("MD5 Hash:", md5(message))



Assignment 7:


SHA


import struct 
 
def sha512(message, key=""): 
    # Initial hash values (first 64 bits of the fractional parts of the square roots of the first 8 
primes) 
    h = [ 
        0x6a09e667f3bcc908, 0xbb67ae8584caa73b, 0x3c6ef372fe94f82b, 0xa54ff53a5f1d36f1, 
        0x510e527fade682d1, 0x9b05688c2b3e6c1f, 0x1f83d9abfb41bd6b, 
0x5be0cd19137e2179 
    ] 
     
    # Round constants (first 64 bits of the fractional parts of the cube roots of the first 80 
primes) 
    k = [ 
       0x428a2f98d728ae22, 0x7137449123ef65cd, 0xb5c0fbcfec4d3b2f, 0xe9b5dba58189dbbc, 
        0x3956c25bf348b538, 0x59f111f1b605d019, 0x923f82a4af194f9b, 0xab1c5ed5da6d8118, 
        0xd807aa98a3030242, 0x12835b0145706fbe, 0x243185be4ee4b28c, 0x550c7dc3d5ffb4e2, 
        0x72be5d74f27b896f, 0x80deb1fe3b1696b1, 0x9bdc06a725c71235, 0xc19bf174cf692694, 
        0xe49b69c19ef14ad2, 0xefbe4786384f25e3, 0x0fc19dc68b8cd5b5, 0x240ca1cc77ac9c65, 
        0x2de92c6f592b0275, 0x4a7484aa6ea6e483, 0x5cb0a9dcbd41fbd4, 0x76f988da831153b5, 
        0x983e5152ee66dfab, 0xa831c66d2db43210, 0xb00327c898fb213f, 0xbf597fc7beef0ee4, 
        0xc6e00bf33da88fc2, 0xd5a79147930aa725, 0x06ca6351e003826f, 0x142929670a0e6e70, 
 	0x27b70a8546d22ffc, 0x2e1b21385c26c926, 0x4d2c6dfc5ac42aed, 0x53380d139d95b3df, 
        0x650a73548baf63de, 0x766a0abb3c77b2a8, 0x81c2c92e47edaee6, 0x92722c851482353b, 
        0xa2bfe8a14cf10364, 0xa81a664bbc423001, 0xc24b8b70d0f89791, 0xc76c51a30654be30, 
        0xd192e819d6ef5218, 0xd69906245565a910, 0xf40e35855771202a, 0x106aa07032bbd1b8, 
        0x19a4c116b8d2d0c8, 0x1e376c085141ab53, 0x2748774cdf8eeb99, 0x34b0bcb5e19b48a8, 
        0x391c0cb3c5c95a63, 0x4ed8aa4ae3418acb, 0x5b9cca4f7763e373, 0x682e6ff3d6b2b8a3, 
        0x748f82ee5defb2fc, 0x78a5636f43172f60, 0x84c87814a1f0ab72, 0x8cc702081a6439ec, 
        0x90befffa23631e28, 0xa4506cebde82bde9, 0xbef9a3f7b2c67915, 0xc67178f2e372532b, 
        0xca273eceea26619c, 0xd186b8c721c0c207, 0xeada7dd6cde0eb1e, 0xf57d4f7fee6ed178, 
        0x06f067aa72176fba, 0x0a637dc5a2c898a6, 0x113f9804bef90dae, 0x1b710b35131c471b, 
        0x28db77f523047d84, 0x32caab7b40c72493, 0x3c9ebe0a15c9bebc, 0x431d67c49c100d4c, 
        0x4cc5d4becb3e42b6, 0x597f299cfc657e2a, 0x5fcb6fab3ad6faec, 0x6c44198c4a475817 
    ] 
    def right_rotate(x, n): 
        return ((x >> n) | (x << (64 - n))) & 0xFFFFFFFFFFFFFFFF 
    def preprocess(message): 
        # Convert message to binary 
        binary = ''.join(format(ord(c), '08b') for c in message) 
        # Append '1' bit 
        binary += '1' 
        # Pad with zeros until length is 896 mod 1024 
        while len(binary) % 1024 != 896: 
            binary += '0' 
        # Append 128-bit big-endian representation of message length 
        length = len(message) * 8 
        binary += format(length, '0128b') 
        return binary 
    def chunk_message(binary): 
        return [binary[i:i + 1024] for i in range(0, len(binary), 1024)]

    def process_chunk(chunk, block_num): 
        nonlocal h 
        words = [int(chunk[i:i + 64], 2) for i in range(0, 1024, 64)] 
    # Extend the 16 words to 80 words 
        for i in range(16, 80): 
            s0 = right_rotate(words[i - 15], 1) ^ right_rotate(words[i - 15], 8) ^ (words[i - 15] >> 7) 
            s1 = right_rotate(words[i - 2], 19) ^ right_rotate(words[i - 2], 61) ^ (words[i - 2] >> 6) 
            words.append((words[i - 16] + s0 + words[i - 7] + s1) & 0xFFFFFFFFFFFFFFFF) 
        # Initialize working variables 
        a, b, c, d, e, f, g, h_temp = h 
        # Main loop 
        for i in range(80): 
            S1 = right_rotate(e, 14) ^ right_rotate(e, 18) ^ right_rotate(e, 41) 
            ch = (e & f) ^ ((~e) & g) 
            temp1 = (h_temp + S1 + ch + k[i] + words[i]) & 0xFFFFFFFFFFFFFFFF 
            S0 = right_rotate(a, 28) ^ right_rotate(a, 34) ^ right_rotate(a, 39) 
            maj = (a & b) ^ (a & c) ^ (b & c) 
            temp2 = (S0 + maj) & 0xFFFFFFFFFFFFFFFF 
            h_temp = g 
            g = f 
            f = e 
            e = (d + temp1) & 0xFFFFFFFFFFFFFFFF 
            d = c 
            c = b 
            b = a 
            a = (temp1 + temp2) & 0xFFFFFFFFFFFFFFFF 
            print(f"Round {i}: {format(a, '016x')}")

     # Update hash values 
        h = [(x + y) & 0xFFFFFFFFFFFFFFFF for x, y in zip(h, [a, b, c, d, e, f, g, h_temp])] 
        print(f"Hash value after block {block_num}: {''.join(format(x, '016x') for x in h)}") 
    # Preprocess the message 
    message = key + message  # Prepend the key for MAC 
    binary = preprocess(message) 
    # Process each 1024-bit chunk 
    for i, chunk in enumerate(chunk_message(binary)): 
        print(f"\nProcessing block {i + 1}") 
        process_chunk(chunk, i + 1) 
 
    # Produce the final hash 
    return ''.join(format(x, '016x') for x in h) 
# Test cases 
print("Test case 1: Message length less than 896 bits") 
message1 = "Hello, Chennai!" 
mac1 = sha512(message1, "secret_key") 
print(f"Final MAC: {mac1}\n") 
print("Test case 2: Message length equal to 896 bits") 
message2 = "A" * 112  # 112 characters * 8 bits = 896 bits 
mac2 = sha512(message2, "secret_key") 
print(f"Final MAC: {mac2}") 



aSSIGNMENT 8: 

DSS

import socket 
import random 
import hashlib 
 
def find_hash(m): 
    if isinstance(m, int): 
        m = str(m) 
    m = str.encode(m) 
    hash_value = hashlib.sha1(m).digest() 
    return int.from_bytes(hash_value, 'big') % q 
 
p = 
3685771234156470351858695099234543629888066548765280822126424419
 6307311217839973541580907141451178893086924929525043030454035301
 3866431229965510814733779933506798365268561425933870873229773800
 6846612203251865088452331297364496795301027082424501771823723224
 1565848208190198213993550445943652619312713670610438036983292483
 0561868635645974615813718599034288471386879791087503489121436698
 3535151216138238675256195373138365465175020820934000073212084150
 5784756262062764491472537599299331846539337456976449678550599812
 5381607827118352697037326000376764847745255637988916261264753020
 6922145357005612247252170797180710944352374021560882734080288389
 3689039813092661675325264454634357108037615811849940012694443305
 6814392717271382689271187098581742948664096320444706415422463846
 7040285204451259350595791575438205824245078790001589821854794119
 4149300782883674438909192898464016516759061806345384754282038359
 15397282804819083435616816897 
q = 
6503284149890351904022205526078130370086322837289625152160489060
 0319447022433 
 
a = int((p - 1) // q) 
h = random.randint(2, p - 2) 
g = pow(h, a, p) 
 
x = random.randint(1, q - 1) 
y = pow(g, x, p) 
 
k = random.randint(1, q - 1) 
r = pow(g, k, p) % q 
message = "attack tomorrow!" 
H = find_hash(message) 
s = (pow(k, -1, q) * (H + x * r)) % q 
 
print("Global Public Key Components:") 
print("P:", p, "\nQ:", q, "\nG:", g) 
 
print("\nx (User's Private Key):",x,"\ny (User's Public Key):", y,"\nk (User's 
Per-Message Secret Number):", k) 
print("Message:",message)

print(f"\nSignature of message '{message}' is [r={r}, s={s}]") 
 
shared = f"{p},{q},{g},{r},{s},{y}".encode() 
incorrect_msg = "Attack Postponed" 
 
with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as serv: 
    serv.bind(('0.0.0.0', 8000))  # Bind to all interfaces 
    serv.listen(5) 
    print("Server is listening...") 
 
    while True: 
        conn, addr = serv.accept() 
        with conn: 
            print(f"Connected by {addr}") 
            conn.send(shared) 
            print("p, q, g, r, s, y sent successfully!") 
 
            ch = input("Send Original Message (y/n): ") 
            if ch == "y": 
                conn.send(message.encode()) 
                print("Signed Message sent successfully!") 
            else: 
                conn.send(incorrect_msg.encode()) 
                print("Unsigned Message sent successfully!")


ASSIGNMENT 9:

ELGAMAL

Code: 
Sender (Client): 
import socket 
import random  
import math 
 
def inverseMod(a, m): 
    for i in range(1, m): 
        if (m * i + 1) % a == 0: 
            return (m * i + 1) // a 
    return None 
 
def elgamal_signature(message: int): 
    q = 101 
    g = 5 
     
    private_key = random.randrange(2, q) 
    public_key = (g ** private_key) % q 
    print("Message:", message) 
    print("Private key:", private_key) 
    print("Public key:", public_key)
    k = 2 
    while math.gcd(k, q-1) != 1: 
        k += 1 
     
    print("K:", k) 
    s1 = (g ** k) % q 
    k_inverse = inverseMod(k, q - 1) 
    print("kinverse:", k_inverse) 
    s2 = (k_inverse * (message - (private_key * s1))) % (q - 1) 
 
    message_to_send = f"{q}|{g}|{message}|{public_key}" 
    print("s1:", s1) 
    print("s2:", s2) 
     
    return s1, s2, message_to_send 
 
def main(): 
    host = socket.gethostname() 
    port = 5000 
    client_socket = socket.socket()  
    client_socket.connect((host, port))  
     
    while True: 
        message = input("Enter the message: ") 
        change_input = input("Change the message (T/F): ") 
        new_message = 0 
        for char in message:
            new_message += ord(char) 
         
        message = int(new_message % 100) 
         
        if not message: 
            break 
 
        s1, s2, message_send = elgamal_signature(message=message) 
        if change_input.lower() == "t": 
            s1 += 1   
        message_send = f"{message_send}|{s1}|{s2}" 
        print("Message to be sent:", message_send) 
        client_socket.send(message_send.encode())  
if __name__ == "__main__": 
    main() 
 
Receiver (Server): 
import socket 
def verify_elgamal(q, g, m, y_a, s1, s2): 
    v1 = (g ** m) % q 
    v2 = ((y_a ** s1) * (s1 ** s2)) % q 
    print("v1:", v1) 
    print("v2:", v2) 
    if v2 == v1: 
        return True 
    else: 
        return False

def main(): 
    host = socket.gethostname() 
    port = 5000 
    server_socket = socket.socket()  
    server_socket.bind((host, port))  
    server_socket.listen(2) 
    conn, address = server_socket.accept()  
    print("Connection To client (Sender)") 
    while True: 
        data = conn.recv(1024).decode() 
        if not data: break 
        q, g, m, y_a, s1, s2 = data.split("|") 
        q = int(q) 
        g = int(g) 
        m = int(m) 
        y_a = int(y_a) 
        s1 = int(s1) 
        s2 = int(s2) 
        print(q, g, m, y_a, s1, s2) 
        is_verified = verify_elgamal(q, g, m, y_a, s1, s2) 
        if is_verified: 
            print("Signature verified successfully") 
        else: 
            print("Failed to verify") 
        print("From connected user:", str(data)) 
        conn.close() 
if __name__ == "__main__": 
    main()


aSSIGNMENT-10

ssl

SSL Connection client server program 
Code: 
Server.py 
import socket 
from socket import AF_INET, SOCK_STREAM, SO_REUSEADDR, SOL_SOCKET, SHUT_RDWR 
import ssl 
 
# Server setup 
listen_addr = '127.0.0.1' 
listen_port = 8082 
server_cert = 'server.crt' 
server_key = 'server.key' 
client_certs = 'client.crt' 
 
# SSL context setup 
context = ssl.create_default_context(ssl.Purpose.CLIENT_AUTH) 
context.verify_mode = ssl.CERT_REQUIRED 
context.load_cert_chain(certfile=server_cert, keyfile=server_key) 
context.load_verify_locations(cafile=client_certs) 
 
# Bind socket 
bindsocket = socket.socket() 
bindsocket.bind((listen_addr, listen_port)) 
bindsocket.listen(5)

while True: 
    print("Waiting for client") 
    newsocket, fromaddr = bindsocket.accept() 
    print("Client connected: {}:{}".format(fromaddr[0], fromaddr[1])) 
     
    # Wrap socket for SSL 
    conn = context.wrap_socket(newsocket, server_side=True) 
    print("SSL established. Peer: {}".format(conn.getpeercert())) 
     
    buf = b''  # Buffer to hold received client data 
     
    try: 
        while True: 
            data = conn.recv(4096) 
            if data: 
                # Client sent us data, append to buffer 
                buf += data 
            else: 
                # No more data from client, print buffer and close connection 
                print("Received:", buf) 
                break 
    finally: 
        print("Closing connection") 
        conn.shutdown(socket.SHUT_RDWR) 
        conn.close()


Client.py  
 
import socket 

import ssl 
 
# Connection settings 
host_addr = '127.0.0.1' 
host_port = 8082 
server_sni_hostname = 'example.com' 
server_cert = 'server.crt' 
client_cert = 'client.crt' 
client_key = 'client.key' 
 
# SSL context setup 
context = ssl.create_default_context(ssl.Purpose.SERVER_AUTH, cafile=server_cert) 
context.load_cert_chain(certfile=client_cert, keyfile=client_key) 
 
# Create and wrap the socket 
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) 
conn = context.wrap_socket(s, server_side=False, server_hostname=server_sni_hostname) 
 
# Connect and communicate 
conn.connect((host_addr, host_port)) 
print("SSL established. Peer: {}".format(conn.getpeercert())) 
print("Sending: 'Hello, world!'") 
conn.send(b"Hello, world!") 
 
# Close connection 
print("Closing connection") 
conn.close()



        
